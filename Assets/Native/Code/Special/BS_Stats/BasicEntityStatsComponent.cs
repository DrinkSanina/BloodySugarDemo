using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BasicEntityStatsComponent : MonoBehaviour
{
    /* А, насчет этого. Зачем было засовывать BasicEntityStats в 
     * обертку-компонент? Прикол в том, что мне нужен BasicEntityStats
     * как обычный класс и как наследник MonoBehaviour. В первом случае я имею
     * обычное хранилище параметров существа - хп, хил в секунду, урон и прочее. Кроме
     * того, я могу создавать экземпляры этого класса, не опираясь на системы Unity, что я
     * и сделал в EffectStatsConverter, когда использую этот же класс, как хранилище дефолтных
     * величин. Во втором случае я имею компонент, который можно навесить на игрока, монстра, да
     * и вообще на что захочу с возможностью выполнять методы MonoBehaviour
     * 
     * Возможные проблеми - когда появятся другие существа с другим набором статов, вероятно мы
     * получим чепалаху прямо пропорционально числу введенных статов, но с этим можно будет что-то
     * сделать
     */

    public BasicEntityStats stats;

    void Start()
    {
        InvokeRepeating("HandleTickingValues", 0f, 0.1f);
    }

    /* Ладно, допустим мое решение сделать хил в секунду и наносимый существу урон
     * в секунду в виде параметров было правильным решением (и клянусь оно 
     * как будто таким и является), но как рассчитывать эти величины в методе Update
     * который запускается каждый кадр, а фреймрейт заведомо неизвестен? Да и привязывать
     * эффект к фреймрейту звучит как-то странно. Поэтому я поместил это в тикающую функцию
     * Сейчас "тик" происходит на протяжении всей игры каждую десятую доли секунды, выглядит
     * это довольно иммерсивно, да и не заставляет просчитывать каждый кадр + такая привязка
     * к секундам упрощает процесс создания эффектов
     * 
     * Из проблеми - рассчет немного хворает по точности, из-за чего появляются оч большие 
     * десятые доли чисел. С этим надо будет что-то потом сделать.
     */
    void HandleTickingValues()
    {
        if (stats.healPerSecond > 0.0f)
            stats.RecieveHealing(stats.healPerSecond / 10.0f);

        if (stats.incomingDamagePerSecond > 0.0f)
            stats.RecieveDamage(stats.incomingDamagePerSecond / 10.0f, DamageSource.effect);
    }
}
